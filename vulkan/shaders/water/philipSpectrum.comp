#version 450
#extension GL_ARB_separate_shader_objects : enable

#define WORKGROUP_SIZE 32
layout (local_size_x = WORKGROUP_SIZE, local_size_y = WORKGROUP_SIZE, local_size_z = 1 ) in;

layout (binding = 0, r32f) uniform readonly image2D noiseTexture0;
layout (binding = 1, r32f) uniform readonly image2D noiseTexture1;
layout (binding = 2, r32f) uniform readonly image2D noiseTexture2;
layout (binding = 3, r32f) uniform readonly image2D noiseTexture3;

layout(binding = 4, rg32f) uniform writeonly image2D h0;
layout(binding = 5, rg32f) uniform writeonly image2D h0Tilde;

#define PI 3.1415926535897932384626433832795
#define PI2 2.0 * PI

layout(push_constant) uniform block
{
   int N;
   int L;

   vec2 windDirection;
   float windSpeed;
   float philipAmplitude;
};

// Acceleration due to gravity
const float g = 9.81f;
const float invSqrt2 = 1.414213f;

vec2 gaussian(float r1, float r2)
{
    float u2 = PI2 * r2;
    float cosU2 = cos(u2);
    float sinU2 = sin(u2);

    float p = sqrt(-2.0 * log(r1));
    return vec2(p * cosU2, p * sinU2);
}

vec2 calculate_h0(ivec2 uv)
{
    //vec2 fuv = uv -	N *	0.5f;
    vec2 k = vec2((PI2 * uv.x) / L,	(PI2 * uv.y) / L);
    float k2 = k.x * k.x + k.y * k.y;
    if(k2 < 0.0001) k2 = 0.0001;
    float l = (windSpeed * windSpeed) / g;
    float l2 = l * l;

    float kdotw = dot(k, windDirection);
    float expComp = philipAmplitude * exp(-1.0f / (k2 * l2));

    float coeff = invSqrt2 * sqrt((expComp * kdotw * kdotw) / (k2 * k2));

    float r1 = imageLoad(noiseTexture0, uv).r;
    float r2 = imageLoad(noiseTexture1, uv).r;
    return coeff * gaussian(r1, r2);
}

vec2 calculate_h0_tilde(ivec2 uv)
{
    vec2 k = vec2((PI2 * uv.x) / L,	(PI2 * uv.y) / L);
    float k2 = k.x * k.x + k.y * k.y;

    float l = (windSpeed * windSpeed) / g;
    float l2 = l * l;

    float kdotw = dot(-k, windDirection);
    float expComp = philipAmplitude * exp(-1.0f / (k2 * l2));

    float coeff = invSqrt2 * sqrt((expComp * kdotw * kdotw) / (k2 * k2));

    float r1 = imageLoad(noiseTexture2, uv).r;
    float r2 = imageLoad(noiseTexture3, uv).r;
    return coeff * gaussian(r1, r2);
}

void main()
{
    ivec2 uv = ivec2(gl_GlobalInvocationID.xy);

	vec4 result	= min(vec4(calculate_h0(ivec2(uv.x,	uv.y)),	0.0f, 0.0f), 10000000.0f);
    imageStore(h0, uv, result);

    result = min(vec4(calculate_h0_tilde(ivec2(uv.x, uv.y)),	0.0f, 0.0f), 10000000.0f);
    imageStore(h0Tilde, uv, result);
}