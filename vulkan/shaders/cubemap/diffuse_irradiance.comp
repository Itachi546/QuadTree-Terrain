#version 450
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive   : require

#include "../shader_constants.h"
#include "cubemap.h"

#define LOCAL_SIZE 8
layout(local_size_x = LOCAL_SIZE, local_size_y = LOCAL_SIZE, local_size_z = 1) in;

layout(binding = 0, rgba16f) uniform readonly imageCube u_cubeMap;
layout(binding = 1, rgba16f) uniform writeonly imageCube u_diffuseIrradiance;

layout(push_constant) uniform Data
{
    int cubemapDims;
    int numStep;
};

void main() 
{
    ivec3 uv = ivec3(gl_GlobalInvocationID.xyz);
    vec2 dims = vec2(cubemapDims);

	vec3 normal = normalize(cubeCoordToWorld(uv, dims));
	vec3 right  = normalize(cross(vec3(0.0, 1.0, 0.0), normal));
	vec3 up     = cross(normal, right);

	float stepTheta = PI_2 / float(numStep);
	float stepPhi = PI2 / float(numStep);

	int totalSample = 0;
	vec3 irradiance = vec3(0.0f);
	for(float theta = 0.0; theta < PI_2; theta += stepTheta)
	{
    	float sinTheta = sin(theta);
	    float cosTheta = cos(theta);
		for(float phi =	0.0; phi < PI2; phi += stepPhi)
		{
    		float cosPhi = cos(phi);
			vec3 tangentSample = vec3(sinTheta * cosPhi, sinTheta *	sin(phi), cosTheta);
			vec3 sampleVec = tangentSample.x * right + tangentSample.y * up	+ tangentSample.z *	normal;
			irradiance += imageLoad(u_cubeMap, texCoordToCube(sampleVec, dims)).rgb	* cosTheta * sinTheta;
			totalSample	++;
	   }
	}
	irradiance = (PI * irradiance) / float(totalSample);
	imageStore(u_diffuseIrradiance, uv, vec4(irradiance, 1.0f));
}
